# Example: Reentrancy with Multiple Colluding Attackers

In this example a reentrancy issue can only be exploited when the attacker
utilizes two colluding smart contracts to exploit the reentrancy. The victim
employs per-address locking to prevent malicious reentrancy. However, during
the callback the first attacker contract can pass control to a second attacker
contract, which in turn can reenter the victim contract.

* `victim.sol` - Implementation of the vulnerable Bank contract (Figure 2 in
  the paper).
* `attack.efcf` - test case generated by EF/CF
* `attack.efcf.yml` - test case generated by EF/CF converted to human readable
  yaml format.
* `attack.efcf.sol` - attacker contract synthesized base on the test case
  generated by EF/CF.
 
 
To start the fuzzing with EF/CF, we can launch it with (adapt the `--cores` to
your machine):
 
```
efcfuzz --source victim.sol --name VulnBankBuggyLockHard --until-crash --timeout 900 --cores 6
``` 

This command instructs EF/CF to fuzz the victim contract
`VulnBankBuggyLockHard` until a crash is discovered. Depending on the machine
this should take a couple of minutes until the first bug, or crash as it called
here, is discovered. EF/CF uses the AFL++ fuzzer to drive the fuzzing process,
so the output directory is very similar to what AFL++ outputs. However, EF/CF
performs several helpful post-processing steps. For example, EF/CF will
automatically minimize crashing test cases. We can run and inspect the
identified crashing test case with:

```
cd ./efcf_out/
./r.sh crashes_min/w5_id:000000,sig:06,src:000276,time:82684,execs:1542787,EM-____e-_____________________-_____-_____-____
```

Using the `efuzzcaseanalyzer` tool (or the `./a.sh` or `./r.sh` wrapper
scripts) we can inspect the generated test case:

```
Block header:
  number: 0
  difficulty: 0
  gas_limit: 0
  timestamp: 0
  initial_ether: 1

TX[0] with tx_sender[0]; tx_receiver[0]; call_value: 0x0; length: 68; block+=0; #returns=0
  func: addAllowance(address,uint256) (0xf3c40c4b)
  input: { address(0xc2018c3f08417e77b94fb541fed2bf1e09093edd), uint(4999999999999999999),  }
TX[1] with tx_sender[0]; tx_receiver[0]; call_value: 0x1; length: 4; block+=0; #returns=0
  func: deposit() (0xd0e30db0)
  input: {  }
TX[2] with tx_sender[0]; tx_receiver[0]; call_value: 0x0; length: 4; block+=0; #returns=1
  func: withdrawBalance() (0x5fd8c710)
  input: {  }
  returns:
    return val: 1; allows reenter: 1; data: 0x
TX[3] with tx_sender[2]; tx_receiver[0]; call_value: 0x0; length: 68; block+=0; #returns=0
  func: transferFrom(address,uint256) (0x1c6adc3)
  input: { address(0xc04689c0c5d48cec7275152b3026b53f6f78d03d), uint(1),  }
TX[4] with tx_sender[2]; tx_receiver[0]; call_value: 0x0; length: 4; block+=0; #returns=1
  func: withdrawBalance() (0x5fd8c710)
  input: {  }
  returns:
    return val: 1; allows reenter: 0; data: 0x
```

All crashing test cases are also converted into Solidity attack contracts in
`./attacks`.
